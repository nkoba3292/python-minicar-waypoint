# imu_debug_bno055.py
# -*- coding: utf-8 -*-
"""
BNO055 IMU „Çª„É≥„Çµ„Éº„Éá„Éê„ÉÉ„Ç∞Áî®„Çµ„É≥„Éó„É´„Ç≥„Éº„Éâ
„É©„Ç∫„Éô„É™„Éº„Éë„Ç§4B + BNO055 „Çª„É≥„Çµ„ÉºÔºà„Ç∑„É™„Ç¢„É´Êé•Á∂öÔºâ

Ê©üËÉΩ:
- BNO055„Å®„ÅÆÂÆâÂÆö„Åó„Åü„Ç∑„É™„Ç¢„É´ÈÄö‰ø°
- Áîü„Éá„Éº„ÇøÔºàÂä†ÈÄüÂ∫¶„ÄÅ„Ç∏„É£„Ç§„É≠„ÄÅÁ£ÅÊ∞óÔºâ„ÅÆÂèñÂæó
- „Çª„É≥„Çµ„Éº„Éï„É•„Éº„Ç∏„Éß„É≥ÁµêÊûúÔºàÂßøÂã¢„ÄÅ„Ç™„Ç§„É©„ÉºËßíÔºâ„ÅÆÂèñÂæó
- „É™„Ç¢„É´„Çø„Ç§„É†Ë°®Á§∫„Å®„Éá„Éº„Çø„É≠„ÇÆ„É≥„Ç∞
- „Ç≠„É£„É™„Éñ„É¨„Éº„Ç∑„Éß„É≥Áä∂ÊÖãÁõ£Ë¶ñ
"""

import serial
import time
import json
import csv
import struct
from datetime import datetime
import threading
import os
import sys

class BNO055Sensor:
    """BNO055 „Çª„É≥„Çµ„ÉºÂà∂Âæ°„ÇØ„É©„Çπ"""
    
    # BNO055 „É¨„Ç∏„Çπ„Çø„Ç¢„Éâ„É¨„Çπ
    REGISTERS = {
        'CHIP_ID': 0x00,
        'ACC_DATA_X_LSB': 0x08,
        'MAG_DATA_X_LSB': 0x0E,
        'GYR_DATA_X_LSB': 0x14,
        'EUL_DATA_X_LSB': 0x1A,
        'QUA_DATA_W_LSB': 0x20,
        'LIA_DATA_X_LSB': 0x28,
        'GRV_DATA_X_LSB': 0x2E,
        'TEMP': 0x34,
        'CALIB_STAT': 0x35,
        'OPR_MODE': 0x3D,
        'PWR_MODE': 0x3E,
        'SYS_TRIGGER': 0x3F,
        'UNIT_SEL': 0x3B
    }
    
    # Âãï‰Ωú„É¢„Éº„Éâ
    OPERATION_MODES = {
        'CONFIG': 0x00,
        'ACCONLY': 0x01,
        'MAGONLY': 0x02,
        'GYRONLY': 0x03,
        'ACCMAG': 0x04,
        'ACCGYRO': 0x05,
        'MAGGYRO': 0x06,
        'AMG': 0x07,
        'IMUPLUS': 0x08,
        'COMPASS': 0x09,
        'M4G': 0x0A,
        'NDOF_FMC_OFF': 0x0B,
        'NDOF': 0x0C
    }
    
    def __init__(self, port='/dev/serial0', baudrate=115200):
        """
        BNO055„Çª„É≥„Çµ„ÉºÂàùÊúüÂåñ
        
        Args:
            port (str): „Ç∑„É™„Ç¢„É´„Éù„Éº„ÉàÔºà„É©„Ç∫„Éë„Ç§„ÅÆÂ†¥ÂêàÈÄöÂ∏∏ /dev/serial0Ôºâ
            baudrate (int): „Éú„Éº„É¨„Éº„Éà
        """
        self.port = port
        self.baudrate = baudrate
        self.serial_conn = None
        self.is_connected = False
        self.data_lock = threading.Lock()
        
        # ÊúÄÊñ∞„Çª„É≥„Çµ„Éº„Éá„Éº„Çø
        self.sensor_data = {
            'timestamp': 0.0,
            'raw': {
                'accelerometer': {'x': 0.0, 'y': 0.0, 'z': 0.0},
                'gyroscope': {'x': 0.0, 'y': 0.0, 'z': 0.0},
                'magnetometer': {'x': 0.0, 'y': 0.0, 'z': 0.0}
            },
            'fusion': {
                'euler': {'roll': 0.0, 'pitch': 0.0, 'yaw': 0.0},
                'quaternion': {'w': 0.0, 'x': 0.0, 'y': 0.0, 'z': 0.0},
                'linear_acceleration': {'x': 0.0, 'y': 0.0, 'z': 0.0},
                'gravity': {'x': 0.0, 'y': 0.0, 'z': 0.0}
            },
            'calibration': {
                'system': 0,
                'gyroscope': 0,
                'accelerometer': 0,
                'magnetometer': 0
            },
            'temperature': 0.0
        }
        
    def connect(self):
        """BNO055„Çª„É≥„Çµ„Éº„Å´Êé•Á∂ö"""
        try:
            print(f"üîå Connecting to BNO055 on {self.port} at {self.baudrate} baud...")
            
            self.serial_conn = serial.Serial(
                port=self.port,
                baudrate=self.baudrate,
                timeout=1.0,
                parity=serial.PARITY_NONE,
                stopbits=serial.STOPBITS_ONE,
                bytesize=serial.EIGHTBITS
            )
            
            time.sleep(2)  # Êé•Á∂öÂæÖÊ©ü
            
            # „ÉÅ„ÉÉ„ÉóIDÁ¢∫Ë™ç
            chip_id = self.read_register(self.REGISTERS['CHIP_ID'])
            if chip_id == 0xA0:  # BNO055„ÅÆ„ÉÅ„ÉÉ„ÉóID
                print(f"‚úÖ BNO055 connected successfully (Chip ID: 0x{chip_id:02X})")
                self.is_connected = True
                return self.initialize_sensor()
            else:
                print(f"‚ùå Invalid chip ID: 0x{chip_id:02X} (expected 0xA0)")
                return False
                
        except Exception as e:
            print(f"‚ùå Connection failed: {e}")
            return False
    
    def initialize_sensor(self):
        """„Çª„É≥„Çµ„ÉºÂàùÊúüÂåñË®≠ÂÆö"""
        try:
            print("üîß Initializing BNO055 sensor...")
            
            # „Ç≥„É≥„Éï„Ç£„Ç∞„É¢„Éº„Éâ„Å´Ë®≠ÂÆö
            self.write_register(self.REGISTERS['OPR_MODE'], self.OPERATION_MODES['CONFIG'])
            time.sleep(0.03)
            
            # „Ç∑„Çπ„ÉÜ„É†„É™„Çª„ÉÉ„Éà
            self.write_register(self.REGISTERS['SYS_TRIGGER'], 0x20)
            time.sleep(1.0)
            
            # Âçò‰ΩçË®≠ÂÆöÔºàÂ∫¶„ÄÅm/s¬≤„ÄÅrpsÔºâ
            self.write_register(self.REGISTERS['UNIT_SEL'], 0x01)
            time.sleep(0.03)
            
            # NDOFÔºà9Ëª∏„Çª„É≥„Çµ„Éº„Éï„É•„Éº„Ç∏„Éß„É≥Ôºâ„É¢„Éº„Éâ„Å´Ë®≠ÂÆö
            self.write_register(self.REGISTERS['OPR_MODE'], self.OPERATION_MODES['NDOF'])
            time.sleep(0.1)
            
            print("‚úÖ BNO055 initialization completed")
            return True
            
        except Exception as e:
            print(f"‚ùå Initialization failed: {e}")
            return False
    
    def read_register(self, address):
        """„É¨„Ç∏„Çπ„Çø„Åã„Çâ1„Éê„Ç§„ÉàË™≠„ÅøÂèñ„Çä"""
        if not self.serial_conn:
            return None
        try:
            # Ë™≠„ÅøÂèñ„Çä„Ç≥„Éû„É≥„ÉâÈÄÅ‰ø°
            command = bytearray([0xAA, 0x01, address, 0x01])
            self.serial_conn.write(command)
            
            # „É¨„Çπ„Éù„É≥„ÇπÂèó‰ø°
            response = self.serial_conn.read(2)
            if len(response) >= 2 and response[0] == 0xBB:
                return response[1]
            return None
        except Exception as e:
            print(f"‚ùå Register read error: {e}")
            return None
    
    def write_register(self, address, value):
        """„É¨„Ç∏„Çπ„Çø„Å´1„Éê„Ç§„ÉàÊõ∏„ÅçËæº„Åø"""
        if not self.serial_conn:
            return False
        try:
            # Êõ∏„ÅçËæº„Åø„Ç≥„Éû„É≥„ÉâÈÄÅ‰ø°
            command = bytearray([0xAA, 0x00, address, 0x01, value])
            self.serial_conn.write(command)
            
            # „É¨„Çπ„Éù„É≥„ÇπÁ¢∫Ë™ç
            response = self.serial_conn.read(2)
            return len(response) >= 2 and response[0] == 0xEE and response[1] == 0x01
        except Exception as e:
            print(f"‚ùå Register write error: {e}")
            return False
    
    def read_vector(self, address, count=3):
        """„Éô„ÇØ„Éà„É´„Éá„Éº„ÇøÔºàË§áÊï∞„Éê„Ç§„ÉàÔºâË™≠„ÅøÂèñ„Çä"""
        if not self.serial_conn:
            return [0.0] * count
        try:
            # Ë™≠„ÅøÂèñ„Çä„Ç≥„Éû„É≥„ÉâÈÄÅ‰ø°
            byte_count = count * 2  # 16„Éì„ÉÉ„ÉàÂÄ§ √ó count
            command = bytearray([0xAA, 0x01, address, byte_count])
            self.serial_conn.write(command)
            
            # „É¨„Çπ„Éù„É≥„ÇπÂèó‰ø°
            response = self.serial_conn.read(byte_count + 1)
            if len(response) >= byte_count + 1 and response[0] == 0xBB:
                values = []
                for i in range(count):
                    lsb = response[1 + i*2]
                    msb = response[2 + i*2]
                    raw_value = (msb << 8) | lsb
                    
                    # 16„Éì„ÉÉ„ÉàÁ¨¶Âè∑‰ªò„ÅçÊï¥Êï∞„Å®„Åó„Å¶Ëß£Èáà
                    if raw_value > 32767:
                        raw_value -= 65536
                    values.append(raw_value)
                return values
            return [0.0] * count
        except Exception as e:
            print(f"‚ùå Vector read error: {e}")
            return [0.0] * count
    
    def update_sensor_data(self):
        """ÂÖ®„Çª„É≥„Çµ„Éº„Éá„Éº„ÇøÊõ¥Êñ∞"""
        if not self.is_connected:
            return False
        
        try:
            with self.data_lock:
                timestamp = time.time()
                
                # Áîü„Éá„Éº„ÇøË™≠„ÅøÂèñ„Çä
                acc_raw = self.read_vector(self.REGISTERS['ACC_DATA_X_LSB'])
                gyro_raw = self.read_vector(self.REGISTERS['GYR_DATA_X_LSB'])
                mag_raw = self.read_vector(self.REGISTERS['MAG_DATA_X_LSB'])
                
                # „Çª„É≥„Çµ„Éº„Éï„É•„Éº„Ç∏„Éß„É≥„Éá„Éº„ÇøË™≠„ÅøÂèñ„Çä
                euler_raw = self.read_vector(self.REGISTERS['EUL_DATA_X_LSB'])
                quat_raw = self.read_vector(self.REGISTERS['QUA_DATA_W_LSB'], 4)
                lin_acc_raw = self.read_vector(self.REGISTERS['LIA_DATA_X_LSB'])
                gravity_raw = self.read_vector(self.REGISTERS['GRV_DATA_X_LSB'])
                
                # „Ç≠„É£„É™„Éñ„É¨„Éº„Ç∑„Éß„É≥Áä∂ÊÖã
                calib_status = self.read_register(self.REGISTERS['CALIB_STAT'])
                
                # Ê∏©Â∫¶
                temp_raw = self.read_register(self.REGISTERS['TEMP'])
                
                # „Éá„Éº„ÇøÂ§âÊèõ„ÉªÊ†ºÁ¥ç
                self.sensor_data.update({
                    'timestamp': timestamp,
                    'raw': {
                        'accelerometer': {
                            'x': acc_raw[0] / 100.0,  # m/s¬≤
                            'y': acc_raw[1] / 100.0,
                            'z': acc_raw[2] / 100.0
                        },
                        'gyroscope': {
                            'x': gyro_raw[0] / 16.0,  # rps
                            'y': gyro_raw[1] / 16.0,
                            'z': gyro_raw[2] / 16.0
                        },
                        'magnetometer': {
                            'x': mag_raw[0] / 16.0,  # ŒºT
                            'y': mag_raw[1] / 16.0,
                            'z': mag_raw[2] / 16.0
                        }
                    },
                    'fusion': {
                        'euler': {
                            'roll': euler_raw[2] / 16.0,   # Â∫¶
                            'pitch': euler_raw[1] / 16.0,
                            'yaw': euler_raw[0] / 16.0
                        },
                        'quaternion': {
                            'w': quat_raw[0] / 16384.0,
                            'x': quat_raw[1] / 16384.0,
                            'y': quat_raw[2] / 16384.0,
                            'z': quat_raw[3] / 16384.0
                        },
                        'linear_acceleration': {
                            'x': lin_acc_raw[0] / 100.0,  # m/s¬≤
                            'y': lin_acc_raw[1] / 100.0,
                            'z': lin_acc_raw[2] / 100.0
                        },
                        'gravity': {
                            'x': gravity_raw[0] / 100.0,  # m/s¬≤
                            'y': gravity_raw[1] / 100.0,
                            'z': gravity_raw[2] / 100.0
                        }
                    },
                    'calibration': {
                        'system': (calib_status >> 6) & 0x03,
                        'gyroscope': (calib_status >> 4) & 0x03,
                        'accelerometer': (calib_status >> 2) & 0x03,
                        'magnetometer': calib_status & 0x03
                    },
                    'temperature': temp_raw if temp_raw else 0
                })
                
            return True
            
        except Exception as e:
            print(f"‚ùå Data update error: {e}")
            return False
    
    def get_sensor_data(self):
        """ÊúÄÊñ∞„Çª„É≥„Çµ„Éº„Éá„Éº„ÇøÂèñÂæóÔºà„Çπ„É¨„ÉÉ„Éâ„Çª„Éº„ÉïÔºâ"""
        with self.data_lock:
            return self.sensor_data.copy()
    
    def disconnect(self):
        """„Çª„É≥„Çµ„ÉºÂàáÊñ≠"""
        if self.serial_conn:
            self.serial_conn.close()
            self.is_connected = False
            print("üîå BNO055 disconnected")

class IMUMonitor:
    """IMU „Éá„Éº„Çø„É™„Ç¢„É´„Çø„Ç§„É†Áõ£Ë¶ñ„Ç∑„Çπ„ÉÜ„É†"""
    
    def __init__(self, sensor):
        self.sensor = sensor
        self.running = False
        self.display_mode = 'compact'  # 'compact' or 'detailed'
        self.log_enabled = False
        self.csv_file = None
        self.csv_writer = None
        
    def start_logging(self, filename=None):
        """„Éá„Éº„Çø„É≠„ÇÆ„É≥„Ç∞ÈñãÂßã"""
        if not filename:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"imu_data_{timestamp}.csv"
        
        try:
            self.csv_file = open(filename, 'w', newline='', encoding='utf-8')
            fieldnames = [
                'timestamp', 'dt',
                'acc_x', 'acc_y', 'acc_z',
                'gyro_x', 'gyro_y', 'gyro_z',
                'mag_x', 'mag_y', 'mag_z',
                'euler_roll', 'euler_pitch', 'euler_yaw',
                'quat_w', 'quat_x', 'quat_y', 'quat_z',
                'lin_acc_x', 'lin_acc_y', 'lin_acc_z',
                'gravity_x', 'gravity_y', 'gravity_z',
                'calib_sys', 'calib_gyro', 'calib_acc', 'calib_mag',
                'temperature'
            ]
            self.csv_writer = csv.DictWriter(self.csv_file, fieldnames=fieldnames)
            self.csv_writer.writeheader()
            self.log_enabled = True
            print(f"üìù Data logging started: {filename}")
        except Exception as e:
            print(f"‚ùå Logging start error: {e}")
    
    def stop_logging(self):
        """„Éá„Éº„Çø„É≠„ÇÆ„É≥„Ç∞ÂÅúÊ≠¢"""
        if self.csv_file:
            self.csv_file.close()
            self.log_enabled = False
            print("üìù Data logging stopped")
    
    def log_data(self, data, prev_timestamp=0.0):
        """„Éá„Éº„Çø„ÇíCSV„Å´Ë®òÈå≤"""
        if not self.log_enabled or not self.csv_writer:
            return
        
        try:
            dt = data['timestamp'] - prev_timestamp if prev_timestamp > 0 else 0.0
            
            row = {
                'timestamp': f"{data['timestamp']:.6f}",
                'dt': f"{dt:.6f}",
                'acc_x': f"{data['raw']['accelerometer']['x']:.3f}",
                'acc_y': f"{data['raw']['accelerometer']['y']:.3f}",
                'acc_z': f"{data['raw']['accelerometer']['z']:.3f}",
                'gyro_x': f"{data['raw']['gyroscope']['x']:.3f}",
                'gyro_y': f"{data['raw']['gyroscope']['y']:.3f}",
                'gyro_z': f"{data['raw']['gyroscope']['z']:.3f}",
                'mag_x': f"{data['raw']['magnetometer']['x']:.1f}",
                'mag_y': f"{data['raw']['magnetometer']['y']:.1f}",
                'mag_z': f"{data['raw']['magnetometer']['z']:.1f}",
                'euler_roll': f"{data['fusion']['euler']['roll']:.2f}",
                'euler_pitch': f"{data['fusion']['euler']['pitch']:.2f}",
                'euler_yaw': f"{data['fusion']['euler']['yaw']:.2f}",
                'quat_w': f"{data['fusion']['quaternion']['w']:.4f}",
                'quat_x': f"{data['fusion']['quaternion']['x']:.4f}",
                'quat_y': f"{data['fusion']['quaternion']['y']:.4f}",
                'quat_z': f"{data['fusion']['quaternion']['z']:.4f}",
                'lin_acc_x': f"{data['fusion']['linear_acceleration']['x']:.3f}",
                'lin_acc_y': f"{data['fusion']['linear_acceleration']['y']:.3f}",
                'lin_acc_z': f"{data['fusion']['linear_acceleration']['z']:.3f}",
                'gravity_x': f"{data['fusion']['gravity']['x']:.3f}",
                'gravity_y': f"{data['fusion']['gravity']['y']:.3f}",
                'gravity_z': f"{data['fusion']['gravity']['z']:.3f}",
                'calib_sys': data['calibration']['system'],
                'calib_gyro': data['calibration']['gyroscope'],
                'calib_acc': data['calibration']['accelerometer'],
                'calib_mag': data['calibration']['magnetometer'],
                'temperature': data['temperature']
            }
            self.csv_writer.writerow(row)
            self.csv_file.flush()
        except Exception as e:
            print(f"‚ùå Logging error: {e}")
    
    def display_compact(self, data):
        """„Ç≥„É≥„Éë„ÇØ„ÉàË°®Á§∫Ôºà1Ë°åÔºâ"""
        calib = data['calibration']
        euler = data['fusion']['euler']
        acc = data['raw']['accelerometer']
        gyro = data['raw']['gyroscope']
        
        # „Ç≠„É£„É™„Éñ„É¨„Éº„Ç∑„Éß„É≥Áä∂ÊÖãË°®Á§∫
        calib_status = f"S{calib['system']}G{calib['gyroscope']}A{calib['accelerometer']}M{calib['magnetometer']}"
        
        display_line = (
            f"üß≠ IMU | "
            f"YAW:{euler['yaw']:7.2f}¬∞ | "
            f"PITCH:{euler['pitch']:+6.2f}¬∞ | "
            f"ROLL:{euler['roll']:+6.2f}¬∞ | "
            f"ACC:[{acc['x']:+6.2f},{acc['y']:+6.2f},{acc['z']:+6.2f}] | "
            f"GYRO:[{gyro['x']:+6.2f},{gyro['y']:+6.2f},{gyro['z']:+6.2f}] | "
            f"CAL:{calib_status} | "
            f"T:{data['temperature']:3d}¬∞C"
        )
        
        print(f"\r{display_line}", end="", flush=True)
    
    def display_detailed(self, data):
        """Ë©≥Á¥∞Ë°®Á§∫"""
        os.system('cls' if os.name == 'nt' else 'clear')
        
        print("üß≠ BNO055 IMU SENSOR DEBUG MONITOR")
        print("="*80)
        print(f"Timestamp: {datetime.fromtimestamp(data['timestamp']).strftime('%H:%M:%S.%f')[:-3]}")
        print(f"Temperature: {data['temperature']}¬∞C")
        print("="*80)
        
        # „Ç≠„É£„É™„Éñ„É¨„Éº„Ç∑„Éß„É≥Áä∂ÊÖã
        calib = data['calibration']
        calib_status = ["‚ùå Poor", "üü° Fair", "üü† Good", "‚úÖ Excellent"]
        print("üéØ CALIBRATION STATUS:")
        print(f"   System:        {calib['system']}/3 {calib_status[calib['system']]}")
        print(f"   Gyroscope:     {calib['gyroscope']}/3 {calib_status[calib['gyroscope']]}")
        print(f"   Accelerometer: {calib['accelerometer']}/3 {calib_status[calib['accelerometer']]}")
        print(f"   Magnetometer:  {calib['magnetometer']}/3 {calib_status[calib['magnetometer']]}")
        print()
        
        # Áîü„Éá„Éº„Çø
        raw = data['raw']
        print("üìä RAW SENSOR DATA:")
        print(f"   Accelerometer [m/s¬≤]: X={raw['accelerometer']['x']:+7.3f} Y={raw['accelerometer']['y']:+7.3f} Z={raw['accelerometer']['z']:+7.3f}")
        print(f"   Gyroscope [rad/s]:    X={raw['gyroscope']['x']:+7.3f} Y={raw['gyroscope']['y']:+7.3f} Z={raw['gyroscope']['z']:+7.3f}")
        print(f"   Magnetometer [ŒºT]:    X={raw['magnetometer']['x']:+7.1f} Y={raw['magnetometer']['y']:+7.1f} Z={raw['magnetometer']['z']:+7.1f}")
        print()
        
        # „Çª„É≥„Çµ„Éº„Éï„É•„Éº„Ç∏„Éß„É≥ÁµêÊûú
        fusion = data['fusion']
        print("üîÑ SENSOR FUSION RESULTS:")
        print(f"   Euler Angles [¬∞]:     Roll={fusion['euler']['roll']:+7.2f} Pitch={fusion['euler']['pitch']:+7.2f} Yaw={fusion['euler']['yaw']:+7.2f}")
        print(f"   Quaternion:           W={fusion['quaternion']['w']:+7.4f} X={fusion['quaternion']['x']:+7.4f} Y={fusion['quaternion']['y']:+7.4f} Z={fusion['quaternion']['z']:+7.4f}")
        print(f"   Linear Accel [m/s¬≤]:  X={fusion['linear_acceleration']['x']:+7.3f} Y={fusion['linear_acceleration']['y']:+7.3f} Z={fusion['linear_acceleration']['z']:+7.3f}")
        print(f"   Gravity [m/s¬≤]:       X={fusion['gravity']['x']:+7.3f} Y={fusion['gravity']['y']:+7.3f} Z={fusion['gravity']['z']:+7.3f}")
        print("="*80)
        print("Commands: [c]ompact mode, [l]og toggle, [q]uit")
    
    def run_monitor(self):
        """Áõ£Ë¶ñ„É´„Éº„ÉóÂÆüË°å"""
        print("üöÄ Starting IMU monitoring...")
        print("Commands: [d]etailed mode, [c]ompact mode, [l]og toggle, [q]uit")
        print("="*80)
        
        self.running = True
        prev_timestamp = 0.0
        
        try:
            while self.running:
                # „Çª„É≥„Çµ„Éº„Éá„Éº„ÇøÊõ¥Êñ∞
                if self.sensor.update_sensor_data():
                    data = self.sensor.get_sensor_data()
                    
                    # Ë°®Á§∫
                    if self.display_mode == 'compact':
                        self.display_compact(data)
                    else:
                        self.display_detailed(data)
                    
                    # „É≠„Ç∞Ë®òÈå≤
                    if self.log_enabled:
                        self.log_data(data, prev_timestamp)
                    
                    prev_timestamp = data['timestamp']
                
                # „Ç≠„ÉºÂÖ•Âäõ„ÉÅ„Çß„ÉÉ„ÇØÔºàÈùû„Éñ„É≠„ÉÉ„Ç≠„É≥„Ç∞Ôºâ
                if sys.stdin in select.select([sys.stdin], [], [], 0)[0]:
                    key = sys.stdin.read(1)
                    self.handle_key_input(key)
                
                time.sleep(0.05)  # 20HzÊõ¥Êñ∞
                
        except KeyboardInterrupt:
            print("\nüõë Monitoring stopped by user")
        except Exception as e:
            print(f"\n‚ùå Monitoring error: {e}")
        finally:
            self.running = False
            if self.log_enabled:
                self.stop_logging()
    
    def handle_key_input(self, key):
        """„Ç≠„ÉºÂÖ•ÂäõÂá¶ÁêÜ"""
        if key.lower() == 'q':
            self.running = False
        elif key.lower() == 'c':
            self.display_mode = 'compact'
            print("\nüì± Switched to compact mode")
        elif key.lower() == 'd':
            self.display_mode = 'detailed'
            print("\nüìã Switched to detailed mode")
        elif key.lower() == 'l':
            if self.log_enabled:
                self.stop_logging()
            else:
                self.start_logging()

def main():
    """„É°„Ç§„É≥ÂÆüË°åÈñ¢Êï∞"""
    print("üß≠ BNO055 IMU Sensor Debug Tool")
    print("="*50)
    print("üîå Hardware Setup:")
    print("   ‚Ä¢ Raspberry Pi 4B")
    print("   ‚Ä¢ BNO055 9-axis IMU sensor")
    print("   ‚Ä¢ Serial connection (UART)")
    print("="*50)
    
    # „Ç∑„É™„Ç¢„É´„Éù„Éº„ÉàË®≠ÂÆöÔºàÁí∞Â¢É„Å´Âøú„Åò„Å¶Â§âÊõ¥Ôºâ
    if os.name == 'nt':  # Windows
        port = 'COM3'  # Windows„ÅÆÂ†¥Âêà
    else:  # Linux/Raspberry Pi
        port = '/dev/serial0'  # „É©„Ç∫„Éë„Ç§„ÅÆGPIO UART
    
    print(f"üì° Connecting to BNO055 on {port}...")
    
    # „Çª„É≥„Çµ„ÉºÂàùÊúüÂåñ
    sensor = BNO055Sensor(port=port)
    
    if not sensor.connect():
        print("‚ùå Failed to connect to BNO055 sensor")
        print("üîß Troubleshooting:")
        print("   1. Check serial port connection")
        print("   2. Verify BNO055 power supply")
        print("   3. Confirm UART configuration")
        print("   4. Check port permissions (Linux)")
        return
    
    # „É¢„Éã„Çø„É™„É≥„Ç∞ÈñãÂßã
    monitor = IMUMonitor(sensor)
    
    try:
        monitor.run_monitor()
    finally:
        sensor.disconnect()
        print("üí§ IMU debug session ended")

if __name__ == "__main__":
    # Windows„ÅÆÂ†¥Âêà„ÅØselect‰∏çË¶Å„Å™ÊñπÊ≥ï„Çí‰ΩøÁî®
    try:
        import select
    except ImportError:
        # Windows„ÅÆÂ†¥Âêà„ÅÆ‰ª£ÊõøÂÆüË£Ö
        import msvcrt
        
        def mock_select_stdin():
            return msvcrt.kbhit()
        
        # select„ÅÆ‰ª£Êõø„Å®„Åó„Å¶‰ΩøÁî®
        sys.stdin.in_select = mock_select_stdin
    
    main()