# main_control_loop.py
# -*- coding: utf-8 -*-
"""
Áµ±Âêà„É°„Ç§„É≥„Ç∑„Çπ„ÉÜ„É† - Ëµ∞Ë°å„É¢„Éº„ÉâÈÅ∏Êäû ‚Üí IMU„Ç≠„É£„É™„Éñ„É¨„Éº„Ç∑„Éß„É≥ ‚Üí „É¨„Éº„ÇπÂÆüË°å
"""
import json
import time
import os
import sys
from datetime import datetime

# IMU„Ç≠„É£„É™„Éñ„É¨„Éº„Ç∑„Éß„É≥„Ç∑„Çπ„ÉÜ„É†„Çí„Ç§„É≥„Éù„Éº„Éà
try:
    from imu_calibration_vehicle_footprint import IMUCalibrationSystem
    CALIBRATION_AVAILABLE = True
except ImportError:
    CALIBRATION_AVAILABLE = False
    print("‚ö†Ô∏è Warning: IMU calibration system not available")

class RaceMonitor:
    """„É¨„Éº„Çπ‰∏≠„ÅÆ„É™„Ç¢„É´„Çø„Ç§„É†Áõ£Ë¶ñ„Ç∑„Çπ„ÉÜ„É†"""
    def __init__(self):
        # Áõ£Ë¶ñ„Éá„Éº„Çø
        self.race_data = {
            'race_time': 0.0,
            'current_waypoint_index': 0,
            'total_waypoints': 0,
            'imu_yaw': 0.0,
            'imu_offset': 0.0,
            'ultrasonic_distances': {'FL': 0.0, 'FR': 0.0, 'BL': 0.0, 'BR': 0.0},
            'current_waypoint': {'x': 0.0, 'y': 0.0, 'v': 0.0, 'yaw': 0.0},
            'next_waypoint': {'x': 0.0, 'y': 0.0, 'v': 0.0, 'yaw': 0.0},
            'vehicle_speed': 0.0,
            'steering_angle': 0.0,
            'distance_to_waypoint': 0.0,
            'battery_level': 100.0,
            'cpu_usage': 0.0
        }
        
    def update_imu_data(self, yaw, offset=0.0):
        """IMU„Éá„Éº„ÇøÊõ¥Êñ∞"""
        self.race_data['imu_yaw'] = yaw
        self.race_data['imu_offset'] = offset
        
    def update_ultrasonic_data(self, fl, fr, bl, br):
        """Ë∂ÖÈü≥Ê≥¢„Çª„É≥„Çµ„Éº„Éá„Éº„ÇøÊõ¥Êñ∞"""
        self.race_data['ultrasonic_distances'] = {
            'FL': fl, 'FR': fr, 'BL': bl, 'BR': br
        }
        
    def update_waypoint_data(self, current_index, waypoints, current_pos=(0.0, 0.0)):
        """„Ç¶„Çß„Ç§„Éù„Ç§„É≥„Éà„Éá„Éº„ÇøÊõ¥Êñ∞"""
        self.race_data['current_waypoint_index'] = current_index
        self.race_data['total_waypoints'] = len(waypoints)
        
        if 0 <= current_index < len(waypoints):
            wp = waypoints[current_index]
            self.race_data['current_waypoint'] = {
                'x': wp.get('x', 0) * 0.05 - 3.2,
                'y': wp.get('y', 0) * 0.05 - 1.5,
                'v': wp.get('v', 100),
                'yaw': wp.get('yaw', 0)
            }
            
            # ÁèæÂú®‰ΩçÁΩÆ„Åã„Çâ„ÅÆË∑ùÈõ¢Ë®àÁÆó
            dx = self.race_data['current_waypoint']['x'] - current_pos[0]
            dy = self.race_data['current_waypoint']['y'] - current_pos[1]
            self.race_data['distance_to_waypoint'] = (dx**2 + dy**2)**0.5
        
        # Ê¨°„ÅÆ„Ç¶„Çß„Ç§„Éù„Ç§„É≥„Éà
        next_index = current_index + 1
        if next_index < len(waypoints):
            wp_next = waypoints[next_index]
            self.race_data['next_waypoint'] = {
                'x': wp_next.get('x', 0) * 0.05 - 3.2,
                'y': wp_next.get('y', 0) * 0.05 - 1.5,
                'v': wp_next.get('v', 100),
                'yaw': wp_next.get('yaw', 0)
            }
            
    def update_vehicle_data(self, speed, steering_angle):
        """Ëªä‰∏°„Éá„Éº„ÇøÊõ¥Êñ∞"""
        self.race_data['vehicle_speed'] = speed
        self.race_data['steering_angle'] = steering_angle
        
    def update_system_data(self, race_time, battery=100.0, cpu=0.0):
        """„Ç∑„Çπ„ÉÜ„É†„Éá„Éº„ÇøÊõ¥Êñ∞"""
        self.race_data['race_time'] = race_time
        self.race_data['battery_level'] = battery
        self.race_data['cpu_usage'] = cpu
        
    def display_monitor_line(self, mode_name="Unknown"):
        """„Ç≥„É≥„Éë„ÇØ„Éà„Å™1Ë°åÁõ£Ë¶ñË°®Á§∫"""
        data = self.race_data
        
        # „Éï„Ç©„Éº„Éû„ÉÉ„ÉàÊ∏à„ÅøË°®Á§∫ÊñáÂ≠óÂàó‰ΩúÊàê
        monitor_line = (
            f"üèÅ {mode_name} | "
            f"T:{data['race_time']:6.1f}s | "
            f"WP:{data['current_waypoint_index']+1:3d}/{data['total_waypoints']:3d} | "
            f"IMU:{data['imu_yaw']:6.1f}¬∞ | "
            f"Speed:{data['vehicle_speed']:6.1f} | "
            f"Steer:{data['steering_angle']:+5.1f}¬∞ | "
            f"Dist:{data['distance_to_waypoint']:5.2f}m | "
            f"US: FL:{data['ultrasonic_distances']['FL']:4.1f} FR:{data['ultrasonic_distances']['FR']:4.1f} | "
            f"Bat:{data['battery_level']:5.1f}%"
        )
        
        # ÁîªÈù¢„ÇØ„É™„Ç¢ÔºãË°®Á§∫ÔºàÂêå„ÅòË°å„ÇíÊõ¥Êñ∞Ôºâ
        print(f"\r{monitor_line}", end="", flush=True)
        
    def display_detailed_monitor(self, mode_name="Unknown"):
        """Ë©≥Á¥∞Áõ£Ë¶ñË°®Á§∫"""
        data = self.race_data
        
        # ÁîªÈù¢„ÇØ„É™„Ç¢ÔºàWindowsÂØæÂøúÔºâ
        os.system('cls' if os.name == 'nt' else 'clear')
        
        print("üèÅ RACE MONITORING DASHBOARD")
        print("="*80)
        print(f"Mode: {mode_name} | Time: {data['race_time']:.1f}s | WP: {data['current_waypoint_index']+1}/{data['total_waypoints']}")
        print("="*80)
        
        # IMU„Éá„Éº„Çø
        print(f"üß≠ IMU Data                üìç Current Waypoint        üöó Vehicle Status")
        print(f"Yaw:    {data['imu_yaw']:6.1f}¬∞         Target: ({data['current_waypoint']['x']:5.1f}, {data['current_waypoint']['y']:5.1f})    Speed:  {data['vehicle_speed']:6.1f}")
        print(f"Offset: {data['imu_offset']:+6.1f}¬∞         Distance: {data['distance_to_waypoint']:5.2f}m       Steering: {data['steering_angle']:+6.1f}¬∞")
        print()
        
        # Ë∂ÖÈü≥Ê≥¢„Çª„É≥„Çµ„Éº
        print(f"üîä Ultrasonic Sensors      üéØ Next Waypoint           ‚ö° System Status")
        print(f"FL: {data['ultrasonic_distances']['FL']:4.1f}m  FR: {data['ultrasonic_distances']['FR']:4.1f}m     Target: ({data['next_waypoint']['x']:5.1f}, {data['next_waypoint']['y']:5.1f})    Battery: {data['battery_level']:5.1f}%")
        print(f"BL: {data['ultrasonic_distances']['BL']:4.1f}m  BR: {data['ultrasonic_distances']['BR']:4.1f}m     Speed: {data['next_waypoint']['v']:6.1f}          CPU: {data['cpu_usage']:5.1f}%")
        print("="*80)
        
    def mock_sensor_update(self):
        """„Çª„É≥„Çµ„Éº„Éá„Éº„Çø„ÅÆ„É¢„ÉÉ„ÇØÊõ¥Êñ∞Ôºà„ÉÜ„Çπ„ÉàÁî®Ôºâ"""
        import random
        
        # „É¢„ÉÉ„ÇØIMU„Éá„Éº„Çø
        self.update_imu_data(random.uniform(0, 360), self.race_data['imu_offset'])
        
        # „É¢„ÉÉ„ÇØË∂ÖÈü≥Ê≥¢„Éá„Éº„Çø
        self.update_ultrasonic_data(
            random.uniform(0.5, 3.0),
            random.uniform(0.5, 3.0),
            random.uniform(0.5, 3.0),
            random.uniform(0.5, 3.0)
        )
        
        # „É¢„ÉÉ„ÇØËªä‰∏°„Éá„Éº„Çø
        self.update_vehicle_data(
            random.uniform(50, 120),
            random.uniform(-30, 30)
        )
        
        # „É¢„ÉÉ„ÇØ„Ç∑„Çπ„ÉÜ„É†„Éá„Éº„Çø
        self.update_system_data(
            self.race_data['race_time'] + 0.1,
            random.uniform(70, 100),
            random.uniform(20, 60)
        )

class MainControlSystem:
    def __init__(self):
        # Ëµ∞Ë°å„É¢„Éº„ÉâÂÆöÁæ©Ôºàwaypoint_editor_multi_mode.py„Å®Âêå„ÅòÔºâ
        self.DRIVING_MODES = {
            'qualifying': {'name': 'Qualifying', 'file': 'waypoints_qualifying.json'},
            'qualifying_backup': {'name': 'Qualifying Backup', 'file': 'waypoints_qualifying_backup.json'},
            'final': {'name': 'Final Race', 'file': 'waypoints_final.json'},
            'final_backup': {'name': 'Final Backup', 'file': 'waypoints_final_backup.json'}
        }
        
        self.selected_mode = None
        self.waypoints = []
        self.calibration_data = None
        self.imu_offset = 0.0
        
        # „Ç∑„Çπ„ÉÜ„É†Áä∂ÊÖã
        self.system_ready = False
        self.calibration_completed = False
        
        # „É¢„Éã„Çø„É™„É≥„Ç∞„Ç∑„Çπ„ÉÜ„É†
        self.monitor = RaceMonitor()
        
    def display_startup_banner(self):
        """„Ç∑„Çπ„ÉÜ„É†Ëµ∑ÂãïÊôÇ„ÅÆ„Éê„Éä„ÉºË°®Á§∫"""
        print("\n" + "="*70)
        print("üèÅ AUTONOMOUS RACING SYSTEM - MAIN CONTROL")
        print("="*70)
        print("System Features:")
        print("‚Ä¢ 4-Mode Waypoint Racing (Qualifying/Final + Backup)")
        print("‚Ä¢ IMU Calibration Integration")
        print("‚Ä¢ Real-time Race Control")
        print("‚Ä¢ Safety & Monitoring")
        print(f"Calibration System: {'‚úÖ Available' if CALIBRATION_AVAILABLE else '‚ùå Not Available'}")
        print("="*70)
    
    def select_driving_mode(self):
        """Ëµ∞Ë°å„É¢„Éº„ÉâÈÅ∏Êäû"""
        print("\nüìã DRIVING MODE SELECTION")
        print("="*50)
        
        # Âà©Áî®ÂèØËÉΩ„Å™„É¢„Éº„ÉâË°®Á§∫
        mode_list = []
        for i, (mode_key, mode_info) in enumerate(self.DRIVING_MODES.items(), 1):
            file_exists = os.path.exists(mode_info['file'])
            status = "‚úÖ Ready" if file_exists else "‚ùå No Data"
            print(f"  {i}. {mode_info['name']} - {status}")
            mode_list.append(mode_key)
        
        # „É¢„Éº„ÉâÈÅ∏Êäû
        while True:
            try:
                print(f"\nSelect mode (1-{len(mode_list)}): ", end="")
                choice = int(input())
                if 1 <= choice <= len(mode_list):
                    selected_key = mode_list[choice - 1]
                    self.selected_mode = selected_key
                    
                    # Waypoint„Éï„Ç°„Ç§„É´Ë™≠„ÅøËæº„Åø
                    waypoint_file = self.DRIVING_MODES[selected_key]['file']
                    if self.load_waypoints(waypoint_file):
                        print(f"‚úÖ Mode Selected: {self.DRIVING_MODES[selected_key]['name']}")
                        print(f"üìç Waypoints Loaded: {len(self.waypoints)} points")
                        return True
                    else:
                        print(f"‚ùå Failed to load waypoints from {waypoint_file}")
                        continue
                else:
                    print("‚ùå Invalid selection. Please try again.")
            except ValueError:
                print("‚ùå Please enter a number.")
            except KeyboardInterrupt:
                print("\nüõë Operation cancelled.")
                return False
    
    def load_waypoints(self, filename):
        """Waypoint„Éï„Ç°„Ç§„É´Ë™≠„ÅøËæº„Åø"""
        try:
            with open(filename, 'r', encoding='utf-8') as f:
                self.waypoints = json.load(f)
            return True
        except Exception as e:
            print(f"‚ùå Error loading waypoints: {e}")
            return False
    
    def run_imu_calibration(self):
        """IMU„Ç≠„É£„É™„Éñ„É¨„Éº„Ç∑„Éß„É≥ÂÆüË°å"""
        if not CALIBRATION_AVAILABLE:
            print("‚ùå IMU Calibration system not available")
            return False
        
        print("\nüéØ IMU CALIBRATION")
        print("="*50)
        print("üì° Starting IMU calibration system...")
        print("üìã Instructions:")
        print("  1. Position vehicle at Pos 1 (red footprint)")  
        print("  2. Click 'Measure IMU 1' button")
        print("  3. Move to Pos 2 (blue footprint)")
        print("  4. Click 'Measure IMU 2' button") 
        print("  5. Click 'Save Results' to complete")
        print("  6. Close the calibration window to continue")
        print("\nüîÑ Launching calibration interface...")
        
        try:
            # IMU„Ç≠„É£„É™„Éñ„É¨„Éº„Ç∑„Éß„É≥„Ç∑„Çπ„ÉÜ„É†ÂÆüË°å
            calibration_system = IMUCalibrationSystem()
            calibration_system.run_calibration_system()
            
            # „Ç≠„É£„É™„Éñ„É¨„Éº„Ç∑„Éß„É≥ÂÆå‰∫ÜÂæå„ÅÆÁ¢∫Ë™ç„É°„ÉÉ„Çª„Éº„Ç∏
            print("\nüéØ Calibration window closed.")
            print("‚è≥ Loading calibration results...")
            
            # „Ç≠„É£„É™„Éñ„É¨„Éº„Ç∑„Éß„É≥ÂÆå‰∫ÜÂæå„ÄÅ„Éï„Ç°„Ç§„É´Ë™≠„ÅøËæº„Åø
            return self.load_calibration_data()
            
        except Exception as e:
            print(f"‚ùå Calibration error: {e}")
            return False
    
    def load_calibration_data(self):
        """„Ç≠„É£„É™„Éñ„É¨„Éº„Ç∑„Éß„É≥„Éá„Éº„ÇøË™≠„ÅøËæº„Åø"""
        calibration_files = ["imu_custom_calib.json"]
        
        for filename in calibration_files:
            try:
                with open(filename, 'r', encoding='utf-8') as f:
                    self.calibration_data = json.load(f)
                
                if self.calibration_data.get('validation', {}).get('is_valid', False):
                    self.imu_offset = self.calibration_data.get('calculated_offset', 0.0)
                    print(f"‚úÖ Calibration loaded: Offset = {self.imu_offset:.2f}¬∞")
                    self.calibration_completed = True
                    return True
                else:
                    print(f"‚ö†Ô∏è Calibration validation failed: {self.calibration_data.get('validation', {}).get('message', 'Unknown error')}")
                    
            except FileNotFoundError:
                continue
            except Exception as e:
                print(f"‚ùå Error reading calibration: {e}")
        
        print("‚ùå No valid calibration data found")
        return False
    
    def system_status_check(self):
        """„Ç∑„Çπ„ÉÜ„É†Áä∂ÊÖãÁ¢∫Ë™ç"""
        print("\nüîç SYSTEM STATUS CHECK")
        print("="*50)
        
        # Ëµ∞Ë°å„É¢„Éº„ÉâÁ¢∫Ë™ç
        mode_status = "‚úÖ Ready" if self.selected_mode else "‚ùå Not Selected"
        waypoint_status = f"‚úÖ {len(self.waypoints)} points" if self.waypoints else "‚ùå No Data"
        
        # „Ç≠„É£„É™„Éñ„É¨„Éº„Ç∑„Éß„É≥Á¢∫Ë™ç
        calib_status = "‚úÖ Completed" if self.calibration_completed else "‚ùå Required"
        offset_info = f"({self.imu_offset:.2f}¬∞)" if self.calibration_completed else ""
        
        print(f"üìã Driving Mode: {mode_status}")
        if self.selected_mode:
            print(f"   ‚Üí {self.DRIVING_MODES[self.selected_mode]['name']}")
        print(f"üìç Waypoints: {waypoint_status}")
        print(f"üéØ IMU Calibration: {calib_status} {offset_info}")
        
        # „Ç∑„Çπ„ÉÜ„É†Ê∫ñÂÇôÂÆå‰∫ÜÂà§ÂÆö
        self.system_ready = (self.selected_mode is not None and 
                           len(self.waypoints) > 0 and 
                           self.calibration_completed)
        
        status_icon = "üü¢" if self.system_ready else "üî¥"
        status_text = "READY FOR RACING" if self.system_ready else "SETUP INCOMPLETE"
        
        print(f"\n{status_icon} System Status: {status_text}")
        return self.system_ready
    
    def wait_for_race_start(self):
        """„É¨„Éº„ÇπÈñãÂßãÂæÖÊ©ü"""
        if not self.system_ready:
            print("‚ùå System not ready for racing")
            return False
        
        print("\nüèÅ RACE START PREPARATION")
        print("="*50)
        print("üìã Pre-race Checklist:")
        print(f"   ‚úÖ Mode: {self.DRIVING_MODES[self.selected_mode]['name']}")
        print(f"   ‚úÖ Waypoints: {len(self.waypoints)} loaded")
        print(f"   ‚úÖ IMU Offset: {self.imu_offset:.2f}¬∞")
        print("\nüöó VEHICLE POSITIONING INSTRUCTIONS:")
        print("="*50)
        print("   1. üéØ Place vehicle at START position on the course")
        print("   2. üß≠ Align vehicle with the start line direction")
        print("   3. üîã Check battery level (ensure sufficient power)")
        print("   4. üëÄ Ensure clear racing path (no obstacles)")
        print("   5. ‚ö° Verify all systems operational")
        print("   6. üîß Double-check vehicle is properly calibrated")
        
        print(f"\nüü¢ System is READY for racing!")
        print(f"‚è≥ When vehicle is positioned correctly, press ENTER to start racing...")
        
        try:
            input()  # EnterÂæÖÊ©ü
            return True
        except KeyboardInterrupt:
            print("\nüõë Race start cancelled.")
            return False
    
    def run_race(self):
        """„É¨„Éº„ÇπÂÆüË°åÔºà„É™„Ç¢„É´„Çø„Ç§„É†„É¢„Éã„Çø„É™„É≥„Ç∞‰ªò„Åç„É°„Ç§„É≥„É´„Éº„ÉóÔºâ"""
        print("\nüèÅ RACE STARTED!")
        print("="*80)
        print(f"üéØ Mode: {self.DRIVING_MODES[self.selected_mode]['name']}")
        print(f"üìç Following {len(self.waypoints)} waypoints")
        print(f"üß≠ IMU Offset: {self.imu_offset:.2f}¬∞")
        print("üîç Real-time monitoring active...")
        print("="*80)
        
        race_start_time = time.time()
        mode_name = self.DRIVING_MODES[self.selected_mode]['name']
        
        # „É¢„Éã„Çø„Éº„Ç∑„Çπ„ÉÜ„É†ÂàùÊúüÂåñ
        self.monitor.update_system_data(0.0)
        
        # „É¨„Éº„Çπ„É´„Éº„ÉóÔºà„É¢„Éã„Çø„É™„É≥„Ç∞Áµ±ÂêàÁâàÔºâ
        try:
            for i, waypoint in enumerate(self.waypoints):
                elapsed = time.time() - race_start_time
                
                # ÁèæÂú®‰ΩçÁΩÆÔºà‰ªÆÊÉ≥‰ΩçÁΩÆ - ÂÆüÈöõ„Å´„ÅØGPS/„Ç™„Éâ„É°„Éà„É™„Åã„ÇâÂèñÂæóÔºâ
                current_pos = (
                    waypoint.get('x', 0) * 0.05 - 3.2,  # ‰ªÆÊÉ≥ÁèæÂú®Âú∞
                    waypoint.get('y', 0) * 0.05 - 1.5
                )
                
                # „É¢„Éã„Çø„É™„É≥„Ç∞„Éá„Éº„ÇøÊõ¥Êñ∞
                self.monitor.update_waypoint_data(i, self.waypoints, current_pos)
                self.monitor.update_system_data(elapsed)
                
                # „Çª„É≥„Çµ„Éº„Éá„Éº„ÇøÊõ¥Êñ∞Ôºà„É¢„ÉÉ„ÇØ - ÂÆüÈöõ„ÅÆ„Çª„É≥„Çµ„Éº„Å®ÁΩÆ„ÅçÊèõ„ÅàÔºâ
                self.monitor.mock_sensor_update()
                
                # IMU„Ç™„Éï„Çª„ÉÉ„ÉàÈÅ©Áî®
                self.monitor.race_data['imu_offset'] = self.imu_offset
                
                # „É™„Ç¢„É´„Çø„Ç§„É†Áõ£Ë¶ñË°®Á§∫
                self.monitor.display_monitor_line(mode_name)
                
                # Âà∂Âæ°„É≠„Ç∏„ÉÉ„ÇØÔºà„Åì„Åì„Å´ÂÆüË£ÖÔºâ
                # - IMUË™≠„ÅøÂèñ„Çä + „Ç™„Éï„Çª„ÉÉ„ÉàË£úÊ≠£
                # - „É¢„Éº„Çø„ÉºÂà∂Âæ°
                # - Ë∂ÖÈü≥Ê≥¢„Çª„É≥„Çµ„ÉºÁõ£Ë¶ñ
                # - Pure Pursuit „Ç¢„É´„Ç¥„É™„Ç∫„É†
                # - ÈöúÂÆ≥Áâ©ÂõûÈÅø
                
                time.sleep(0.1)  # Âà∂Âæ°Âë®ÊúüÔºà10HzÔºâ
                
                # Ë©≥Á¥∞Ë°®Á§∫„É¢„Éº„ÉâÂàá„ÇäÊõø„ÅàÔºà„Éá„Éê„ÉÉ„Ç∞Áî®Ôºâ
                # 5Áßí„Åî„Å®„Å´Ë©≥Á¥∞Ë°®Á§∫Ôºà„Ç™„Éó„Ç∑„Éß„É≥Ôºâ
                if i % 50 == 0 and i > 0:  # 5Áßí„Åî„Å®
                    print()  # ÊîπË°å
                    self.monitor.display_detailed_monitor(mode_name)
                    time.sleep(2)  # 2ÁßíÈñìË©≥Á¥∞Ë°®Á§∫
                
        except KeyboardInterrupt:
            print(f"\nüõë RACE STOPPED (Manual Stop)")
            
        except Exception as e:
            print(f"\n‚ùå RACE ERROR: {e}")
            
        finally:
            # „É¨„Éº„ÇπÁµÇ‰∫ÜÂá¶ÁêÜ
            total_time = time.time() - race_start_time
            print(f"\n\nüèÅ RACE COMPLETED")
            print("="*80)
            print(f"   Total Time: {total_time:.1f} seconds")
            print(f"   Waypoints: {len(self.waypoints)} processed")
            print(f"   Mode: {mode_name}")
            print(f"   Final Waypoint: {self.monitor.race_data['current_waypoint_index']+1}")
            print("="*80)
            
            # ÊúÄÁµÇÁµ±Ë®àË°®Á§∫
            print("\nüìä RACE STATISTICS:")
            print(f"   Average Speed: {self.monitor.race_data['vehicle_speed']:.1f}")
            print(f"   Final IMU Reading: {self.monitor.race_data['imu_yaw']:.1f}¬∞")
            print(f"   IMU Offset Used: {self.imu_offset:.2f}¬∞")
    
    def main_loop(self):
        """„É°„Ç§„É≥„Ç∑„Çπ„ÉÜ„É†„É´„Éº„Éó"""
        self.display_startup_banner()
        
        try:
            # ‚ë† Ëµ∞Ë°å„É¢„Éº„ÉâÈÅ∏Êäû
            if not self.select_driving_mode():
                print("üõë System startup cancelled.")
                return
            
            # ‚ë° IMU„Ç≠„É£„É™„Éñ„É¨„Éº„Ç∑„Éß„É≥
            print(f"\nüéØ Ready for IMU calibration...")
            if not self.run_imu_calibration():
                print("‚ùå Calibration required for racing.")
                return
            
            # ‚ë¢ „Ç∑„Çπ„ÉÜ„É†Áä∂ÊÖãÁ¢∫Ë™ç
            if not self.system_status_check():
                print("‚ùå System setup incomplete.")
                return
            
            # ‚ë£ „É¨„Éº„ÇπÈñãÂßãÂæÖÊ©ü
            if not self.wait_for_race_start():
                print("üõë Race cancelled.")
                return
            
            # ‚ë§ „É¨„Éº„ÇπÂÆüË°å
            self.run_race()
            
        except Exception as e:
            print(f"\n‚ùå System Error: {e}")
        
        finally:
            print("\nüì¥ Main Control System shutdown.")

def main():
    """„É°„Ç§„É≥ÂÆüË°åÈñ¢Êï∞"""
    system = MainControlSystem()
    system.main_loop()

if __name__ == "__main__":
    main()